<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Precision Speed Test</title>
    <style>
        /* --- Nordic Design System --- */
        :root {
            --bg-color: #ECEFF4;
            --card-bg: #FFFFFF;
            --text-main: #2E3440;
            --text-sub: #4C566A;
            --accent-blue: #5E81AC;
            --accent-green: #A3BE8C;
            --accent-red: #BF616A;
            --shadow: 0 8px 30px rgba(46, 52, 64, 0.12);
            --radius: 12px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
        }

        .container {
            width: 100%;
            max-width: 600px;
            display: grid;
            gap: 20px;
        }

        /* Card Styles */
        .card {
            background: var(--card-bg);
            border-radius: var(--radius);
            padding: 30px;
            box-shadow: var(--shadow);
            text-align: center;
        }

        h1 {
            font-size: 1.4rem;
            margin: 0 0 5px 0;
            color: var(--text-main);
            letter-spacing: 0.05em;
        }
        .subtitle {
            font-size: 0.85rem;
            color: var(--text-sub);
            margin-bottom: 25px;
        }

        /* Speed Display */
        .speed-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }
        .stat-box {
            background: #F4F6F8;
            padding: 15px;
            border-radius: 8px;
        }
        .stat-label {
            font-size: 0.8rem;
            color: var(--text-sub);
            margin-bottom: 5px;
            font-weight: bold;
        }
        .stat-value {
            font-size: 2rem;
            font-weight: 800;
            color: var(--text-main);
            font-variant-numeric: tabular-nums;
        }
        .stat-unit { font-size: 0.9rem; font-weight: normal; color: #888; }
        .active-measure { color: var(--accent-blue); }

        /* Ping Info */
        .ping-info {
            display: flex;
            justify-content: center;
            gap: 20px;
            font-size: 0.9rem;
            color: var(--text-sub);
            margin-bottom: 20px;
        }

        /* Progress Bar */
        .progress-wrapper {
            height: 4px;
            background: #E5E9F0;
            border-radius: 2px;
            margin: 20px 0;
            overflow: hidden;
        }
        .progress-bar {
            height: 100%;
            width: 0%;
            background: var(--accent-blue);
            transition: width 0.2s linear;
        }

        /* Button */
        button {
            background: var(--text-main);
            color: white;
            border: none;
            padding: 16px 40px;
            font-size: 1rem;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            width: 100%;
            transition: transform 0.1s, opacity 0.2s;
        }
        button:hover { opacity: 0.9; }
        button:active { transform: scale(0.98); }
        button:disabled { background: #D8DEE9; color: #999; cursor: not-allowed; }

        /* Status Text */
        #status {
            margin-top: 15px;
            font-size: 0.85rem;
            color: var(--text-sub);
            min-height: 1.2em;
        }

        /* Result Analysis */
        #result-area {
            display: none; /* 初期は非表示 */
            margin-top: 20px;
            text-align: left;
            border-top: 1px solid #eee;
            padding-top: 20px;
        }
        .result-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 4px;
            color: white;
            font-weight: bold;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }
        .bg-green { background: var(--accent-green); }
        .bg-blue { background: var(--accent-blue); }
        .bg-yellow { background: #EBCB8B; color: #555; }
        .bg-red { background: var(--accent-red); }

        .capability-list {
            margin: 10px 0 0 0;
            padding-left: 20px;
            font-size: 0.9rem;
            color: var(--text-sub);
            line-height: 1.6;
        }
    </style>
</head>
<body>

<div class="container">
    <div class="card">
        <h1>NETWORK TEST</h1>
        <div class="subtitle">高精度・長時間測定モード (15秒)</div>

        <div class="speed-grid">
            <div class="stat-box">
                <div class="stat-label">ダウンロード</div>
                <div class="stat-value" id="dl-val">--</div>
                <span class="stat-unit">Mbps</span>
            </div>
            <div class="stat-box">
                <div class="stat-label">アップロード</div>
                <div class="stat-value" id="ul-val">--</div>
                <span class="stat-unit">Mbps</span>
            </div>
        </div>

        <div class="ping-info">
            <span>Ping: <b id="ping-val">--</b> ms</span>
            <span>Jitter: <b id="jitter-val">--</b> ms</span>
        </div>

        <div class="progress-wrapper">
            <div class="progress-bar" id="progress"></div>
        </div>

        <button id="start-btn">測定開始</button>
        <div id="status">準備完了</div>

        <div id="result-area">
            <span id="grade-badge" class="result-badge">判定中...</span>
            <div id="grade-comment"></div>
            <ul class="capability-list" id="capability-list"></ul>
        </div>
    </div>
</div>

<script>
    // 設定: テストファイルのパス（必ず同じ場所に test.jpg を置いてください）
    const TEST_FILE_URL = "./test.jpg"; 
    // 設定: 測定時間 (ミリ秒) - 15秒推奨
    const TEST_DURATION = 15000; 
    // 設定: アップロード用エンドポイント (外部サービス利用のため不安定な場合は除外検討)
    const UPLOAD_ENDPOINT = "https://httpbin.org/post";

    const ui = {
        btn: document.getElementById('start-btn'),
        dlVal: document.getElementById('dl-val'),
        ulVal: document.getElementById('ul-val'),
        pingVal: document.getElementById('ping-val'),
        jitterVal: document.getElementById('jitter-val'),
        progress: document.getElementById('progress'),
        status: document.getElementById('status'),
        resultArea: document.getElementById('result-area'),
        gradeBadge: document.getElementById('grade-badge'),
        gradeComment: document.getElementById('grade-comment'),
        capList: document.getElementById('capability-list')
    };

    const sleep = ms => new Promise(r => setTimeout(r, ms));

    // --- 1. Ping測定 ---
    async function measurePing() {
        ui.status.innerText = "応答速度を測定中...";
        const pings = [];
        
        // 5回計測して平均を取る
        for (let i = 0; i < 5; i++) {
            const start = performance.now();
            try {
                // キャッシュ回避のためランダムクエリを付与
                await fetch(`${window.location.href}?ping=${Math.random()}`, { method: 'HEAD', cache: 'no-store' });
                const end = performance.now();
                pings.push(end - start);
            } catch (e) {
                pings.push(100); // エラー時は仮の値
            }
            await sleep(100);
        }

        const min = Math.min(...pings);
        const avg = pings.reduce((a, b) => a + b) / pings.length;
        const jitter = pings.reduce((a, b) => a + Math.abs(b - avg), 0) / pings.length;

        ui.pingVal.innerText = min.toFixed(0);
        ui.jitterVal.innerText = jitter.toFixed(0);
        return min;
    }

    // --- 2. ダウンロード測定 (ループ方式) ---
    async function measureDownload() {
        ui.status.innerText = "ダウンロード速度測定中 (15秒)...";
        ui.dlVal.parentElement.classList.add('active-measure');
        
        let totalBytesLoaded = 0;
        const startTime = performance.now();
        const endTime = startTime + TEST_DURATION;
        
        // 進捗バーのアニメーション用ループ
        const progressInterval = setInterval(() => {
            const now = performance.now();
            const elapsed = now - startTime;
            const percent = Math.min((elapsed / TEST_DURATION) * 100, 100);
            ui.progress.style.width = percent + "%";
            
            // リアルタイム速度表示 (経過時間が1秒を超えてから表示)
            if (elapsed > 1000) {
                const currentSpeed = (totalBytesLoaded * 8 / (elapsed / 1000)) / 1000000;
                ui.dlVal.innerText = currentSpeed.toFixed(1);
            }
        }, 100);

        // データフェッチングのループ
        try {
            while (performance.now() < endTime) {
                // キャッシュバスターを超強力にする（タイムスタンプ + ランダム）
                const uniqueUrl = `${TEST_FILE_URL}?t=${Date.now()}&r=${Math.random()}`;
                
                const response = await fetch(uniqueUrl);
                if (!response.ok) throw new Error("DL Error");

                const reader = response.body.getReader();
                
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    totalBytesLoaded += value.length;

                    // 時間切れならループ脱出
                    if (performance.now() >= endTime) {
                        reader.cancel();
                        break;
                    }
                }
            }
        } catch (e) {
            console.error(e);
        } finally {
            clearInterval(progressInterval);
            ui.progress.style.width = "0%";
            ui.dlVal.parentElement.classList.remove('active-measure');
        }

        // 最終計算
        const finalTime = (performance.now() - startTime) / 1000;
        const finalSpeedMbps = (totalBytesLoaded * 8 / finalTime) / 1000000;
        
        ui.dlVal.innerText = finalSpeedMbps.toFixed(1);
        return finalSpeedMbps;
    }

    // --- 3. アップロード測定 (擬似) ---
    async function measureUpload() {
        // アップロードは回線負荷やAPI制限を考慮し、短め(5-8秒)にするか、軽量パケットを繰り返す
        ui.status.innerText = "アップロード速度測定中...";
        ui.ulVal.parentElement.classList.add('active-measure');

        let totalBytesUploaded = 0;
        const upDuration = 8000; // アップロードは少し短めに設定(API制限回避)
        const startTime = performance.now();
        const endTime = startTime + upDuration;
        
        // 1MBのダミーデータ
        const chunkData = new Blob([new Array(1024 * 1024).fill('a').join('')]);

        const progressInterval = setInterval(() => {
            const now = performance.now();
            const elapsed = now - startTime;
            ui.progress.style.width = Math.min((elapsed / upDuration) * 100, 100) + "%";
            
            if (elapsed > 1000 && totalBytesUploaded > 0) {
                const currentSpeed = (totalBytesUploaded * 8 / (elapsed / 1000)) / 1000000;
                ui.ulVal.innerText = currentSpeed.toFixed(1);
            }
        }, 100);

        try {
            // 並列リクエスト数（高速回線用）
            const parallel = 2; 

            // API制限を考慮しつつループ
            while (performance.now() < endTime) {
                const promises = [];
                for(let i=0; i<parallel; i++) {
                    promises.push(
                        fetch(UPLOAD_ENDPOINT, {
                            method: 'POST',
                            body: chunkData,
                            mode: 'cors'
                        }).then(() => {
                            totalBytesUploaded += chunkData.size;
                        }).catch(e => console.log("Upload packet drop")) // 失敗は無視して続行
                    );
                }
                await Promise.all(promises);
            }

        } catch (e) {
            console.error(e);
        } finally {
            clearInterval(progressInterval);
            ui.progress.style.width = "0%";
            ui.ulVal.parentElement.classList.remove('active-measure');
        }

        const finalTime = (performance.now() - startTime) / 1000;
        // データが0の場合はエラー扱い
        if(totalBytesUploaded === 0) {
            ui.ulVal.innerText = "Error";
            return 0;
        }

        const finalSpeedMbps = (totalBytesUploaded * 8 / finalTime) / 1000000;
        ui.ulVal.innerText = finalSpeedMbps.toFixed(1);
        return finalSpeedMbps;
    }

    // --- 結果判定 ---
    function showResults(dl, ul, ping) {
        ui.resultArea.style.display = "block";
        
        let grade = "";
        let colorClass = "";
        let comments = "";
        let caps = [];

        // 判定ロジック
        if (dl >= 200) {
            grade = "非常に高速 (S)";
            colorClass = "bg-blue";
            comments = "光回線などの非常に安定した環境です。";
            caps = ["8K動画のストリーミング再生", "大容量ゲームの高速ダウンロード", "複数デバイスでの同時利用"];
        } else if (dl >= 80) {
            grade = "高速 (A)";
            colorClass = "bg-green";
            comments = "日常利用で困ることはほぼありません。";
            caps = ["4K動画の視聴", "快適なオンラインゲーム", "Web会議 (Zoom/Teams)"];
        } else if (dl >= 30) {
            grade = "普通 (B)";
            colorClass = "bg-green";
            comments = "標準的な速度です。";
            caps = ["HD動画 (1080p) の視聴", "Webブラウジング", "SNSの利用"];
        } else {
            grade = "低速 (C)";
            colorClass = "bg-red";
            comments = "動画が止まるなどの影響が出る可能性があります。";
            caps = ["テキストサイトの閲覧", "メール・LINE", "低画質での動画再生"];
        }

        if (ping > 50) {
            comments += "<br><small>※応答速度(Ping)が遅いため、アクションゲーム等でラグを感じるかもしれません。</small>";
        }

        ui.gradeBadge.className = "result-badge " + colorClass;
        ui.gradeBadge.innerText = grade;
        ui.gradeComment.innerHTML = comments;
        ui.capList.innerHTML = caps.map(c => `<li>${c}</li>`).join('');
    }

    // --- 実行 ---
    ui.btn.addEventListener('click', async () => {
        // UIリセット
        ui.btn.disabled = true;
        ui.resultArea.style.display = "none";
        ui.dlVal.innerText = "--";
        ui.ulVal.innerText = "--";
        
        // 1. Ping
        const ping = await measurePing();
        
        // 2. Download
        const dl = await measureDownload();
        
        // 3. Upload
        const ul = await measureUpload();

        // 完了
        ui.status.innerText = "測定完了";
        ui.btn.disabled = false;
        ui.btn.innerText = "再測定";
        
        showResults(dl, ul, ping);
    });
</script>

</body>
</html>
